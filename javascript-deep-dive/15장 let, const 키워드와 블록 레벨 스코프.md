# 15장 let, const 키워드와 블록 레벨 스코프

### var 키워드

- var 키워드로 변수 선언을 할 때, 변수 이름이 중복되었다면 초기화문이 있는 변수는 var 키워드가 없는 것 처럼 동작하고, 초기화문이 없는 변수는 무시된다.(이 때, 에러 발생은 하지 않는다.)

<br />

- var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
    - 오로지 함수 코드 블록만을 지역 스코프로 인정한다.

<br />

- var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.
    - 변수 선언문 이전에 참조할 수 있다.(이 때 값은 undefined)

<br />

### let 키워드

- 이름이 같은 변수를 선언하면 `SyntaxError` 가 발생한다.

<br />

- 함수를 포함한 모든 코드 블록을 지역 스코프로 인정하는 **블록 레벨 스코프**(block-level scope)를 따른다.

<br />

- **변수 호이스팅이 발생하지 않는 것처럼 동작**한다.
    - 변수 선언문 이전에 참조하면 `ReferenceError` 가 발생한다.
    - let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행된다.

```jsx
let a = 1; // 전역 변수

{
	console.log(a); // ReferenceError: Cannot access 'a' before initialization
	let a = 2; // 지역 변수
}
// 호이스팅 되지 않는다면 1이 출력되어야 한다.
```

<br />

- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.

### const 키워드

- const 키워드로 선언한 변수는 **반드시 선언과 동시에 초기화**해야 한다.

```jsx
const a = 1;
const a; // SyntaxError: Missing initializer in const declaration
```

<br />

- let과 마찬가지로 **블록 레벨 스코프**를 가지며, **변수 호이스팅이 발생하지 않는 것처럼 동작**한다.

<br />

- **재할당이 금지**된다.

<br />

- 원시 값은 변경이 불가능하고, const 키워드로 선언한 변수는 재할당이 금지되므로 상수를 표현하는데 사용할 수 있다.
    - 일반적으로 상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다.
    - 재할당이 금지될 뿐 불변을 의미하는 것이 아니므로 객체를 할당한 경우 값을 변경할 수 있다.

<br />

# 🤔 문제

1. 다음 코드의 출력 결과는?

```jsx
let x = 1;

if (x === 1) {
	let x = 2;

	console.log(x); // ??
}

console.log(x); // ??
```

<br />

- 답
    
    2 1
    
    let 은 **블록 레벨 스코프**이므로 if문 내부의 x는 지역 변수 2를 출력하고, if문 외부의 x는 전역 변수인 1을 출력한다. 
    

<br />

2. 다음 중 올바르지 않은 내용은?
    1. 변수를 선언할 때 변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록하는 것을 선언 단계라고 한다.
    2. 변수가 초기화되지 않았다는 말은 식별자로 해당 변수를 참조할 수 없다는 것을 의미한다.
    3. const 키워드로 객체를 할당했을 때 객체의 프로퍼티는 보호되지 않는다.
    4. const는 반드시 선언과 동시에 할당이 이루어져야 한다.

<br />

- 답
    
    b.
    
    변수가 아직 초기화되지 않았다는 것은 변수를 위한 **메모리 공간이 아직 확보되지 않았다는 것**을 의미한다.